/* 
Create a basic cron system using Eventing allows a recurring function to execute activity
a specified tie every day.  We used the 'travel-sample' and placed a control document 
of type == "recurring_event" for this example.  Note for testing uncomment out the line 
after TEST_ONLY.  Important you will need to alias 'travel-sample' to 'ts' when you add 
this function into Eventing.

Test Doc: 
   {
        "type":"recurring_event",   // The KEY will be <<type>>::<<id>>
        "id":1,                     // 
        "hour":14,                  // The hour of the day 0-23, *, *2X, *4X to trigger
        "min":54,                   // The minute in the hour 0-59, *, *2X, *4X to trigger
        "action":"doCronActionA",   // What function to run on the trigger
        "verbose":2,                // Logging level: 0=none, 1 or 2=action, 3=lots
        "active":false              // Flag to arm or disable this schedule
    } 
    
    INSERT INTO `travel-sample` (KEY,VALUE) VALUES ("recurring_event::1", 
    {
        "type":"recurring_event",
        "id":1,
        "hour":14,
        "min":54,
        "action":"doCronActionA",
        "verbose":2,
        "active":false
    } 
);

N1QL : Verify or inspect settings in schedule	        
    SELECT * FROM `travel-sample` WHERE type="recurring_event";

N1QL : Arm or set active	    
    UPDATE `travel-sample` SET active = true WHERE type="recurring_event" AND id=1 ;
    
N1QL : Disarm or set inactive	
    UPDATE `travel-sample` SET active = false WHERE type="recurring_event" AND id=1 ;
    
N1QL : Adjust time of trigger	
    UPDATE `travel-sample` SET hour = 11 AND min = 30 WHERE type="recurring_event" AND id=1 ;

N1QL : Adjust logging	        
    UPDATE `travel-sample` SET verbose = 0 WHERE type="recurring_event" AND id=1 ;

N1QL : Delete the schedule	    
    DELETE FROM `travel-sample` WHERE type="recurring_event" AND id=1 ;
         
The action is important it 'should' exist in this Eventing Function if could be any 
JavaScript name e.g. MyFunc and you must implement is as say doCronActionA(doc) where doc 
will be the currently active item of type = 'recurring_event' read from the source bucket
when the timer is fired.  This should return  true or false used for logging purposes.  If
the action does not exist it is an error and a warning is logged and the timer is disabled.

In 6.5+ add a new cron like daily function just pause the active handler insert your new 
function doCronActionB(doc) {...} then Resume the eventing handler.  The nice thing is if
a time was to be fired will the function was paused it will NOT be lost, when you resume 
the function it will be processed.
*/

// ==================
/* BEG USER FUNCTIONS TO RUN ONCE A DAY, HOUR, OR MINUTE - ANYTHING YOU WANT BELOW */
function doCronActionA(doc) {
  // check that doc has desired values
  if (doc.type !== "recurring_event" || doc.active != true) return;
  if (doc.verbose >= 1)
    log(doc.action + ' user action controlled by ', doc.type + '::' + doc.id);
  // this is a 6.5 N1QL query (feature not available prior to 6.5)
  try {
    // Create an embedded N1QL iterator by issuing a SELECT statement to get the
    // counts of airlines by country.  Make a new document and write it out to KV 

    // We will use the iterator to create a KV document representing the results of a
    // HARD lengthy embedded N1QL query and write it back to KV, the idea is to keep
    // a calculation up to date once a day such that it that can be read 'quickly' 
    // by other Eventing Functions, other Couchbase services or SDKs.   

    // Consider if we had 1 million docs in a minute do we really want to use N1QL
    // to recalculate something that is almost static for all 1 million documents, of 
    // course not, so we make an intermediate value that can be read into Eventing
    // and used via a single 'light weight' KV read.

    var q_iter = SELECT country,
      count( * ) cnt
    FROM `travel-sample`
    WHERE `type` = 'airline'
    GROUP BY country;

    // loop through the result set and update the map 'accumulate'
    var accumulate = {};
    var idx = 0;
    for (var val of q_iter) {
      if (doc.verbose >= 2)
        log(doc.action + ' N1QL idx ' + idx + ', country ' + val.country + " cnt " + val.cnt);
      accumulate[val.country] = val.cnt;
      idx++;
    }
    // close out embedded N1QL iterator
    q_iter.close();

    // Now letâ€™s make a cached KV document representing a HARD length embedded N1QL
    // query and write it back to KV, we need a KEY and a type and id and then we 
    // upsert it into the `travel-sample` bucket.

    var cachedoc = {};
    cachedoc.type = "cron_cache";
    cachedoc.id = "airlines_by_country";
    cachedoc.date = new Date();
    cachedoc.data = accumulate;
    var ckey = cachedoc.type + '::' + cachedoc.id;
    ts[ckey] = cachedoc;
    if (doc.verbose >= 2) {
      log(doc.action + ' upsert to KV with KEY ' + ckey + ' cachedoc ', cachedoc);
    }
  } catch (e) {
    log(doc.action + ' Error exception NIQL:', e);
    return false;
  }
  return true;
}

function doCronActionB(doc) {
  // check that doc has desired values
  if (doc.type !== "recurring_event" || doc.active != true) return;
  if (doc.verbose >= 1)
    log(doc.action + ' user action controlled by ', doc.type + '::' + doc.id);

  // YOUR LOGIC HERE

  return true;
}

function doCronActionC(doc) {
  // check that doc has desired values
  if (doc.type !== "recurring_event" || doc.active != true) return;
  if (doc.verbose >= 1)
    log(doc.action + ' user action controlled by ', doc.type + '::' + doc.id);

  // YOUR LOGIC HERE

  return true;
}

/* END USER FUNCTIONS TO RUN ONCE A DAY, HOUR, OR MINUTE - ANYTHING YOU WANT ABOVE */
// ==================

function OnUpdate(doc, meta) {
  // Check if further analysis is needed we only trigger on an active recurring_event 
  if (doc.type !== "recurring_event" || doc.active != true) return;
  // log("SETUP id " + doc.id + " type " + doc.type + " active " , doc.active);

  var id = doc.type + "::" + doc.id; // this is the same as meta.id or the KEY
  var hour = doc.hour;
  var min = doc.min;

  // Do an eval check the JavaScript function exists. The eval occurs in a common 
  // utility function shared with RecurringCallback
  if (!verifyFunctionExistsViaEval(doc, id)) {
    // doc.action did not exist, we have already logged the issue
    return;
  }

  // Get the next valid execution time
  var date_timer = getNextRecurringDate(hour, min);
  if (doc.verbose >= 3) {
    log("OnUpdate (sched date) " + date_timer);
    log('OnUpdate create recurring timer for id ', id);
  }

  // Schedule an Eventing timer
  createTimer(RecurringCallback, date_timer, id, doc);
}

function getNextRecurringDate(hour_str, min_str) {

  // Note JavaScript Dates are in milliseconds
  var date_now = new Date();
  var date_ret = new Date();

  var hour;
  var min;
  try {
    hour = parseInt(hour_str);
  } catch (e) {}
  try {
    min = parseInt(min_str);
  } catch (e) {}

  // Note, this is only a simplistic partial 'crontab' syntax with some slight extensions
  // it allows once a day, once an hour, once a minute.  It also contains some non-standard 
  // syntax to provide the ability to execute twice a minute or four times a minute.

  if (hour_str === '*4X' && min_str === '*4X') {
    // once every 15 seconds or four times a minute
    date_ret.setMilliseconds(0);
    date_ret.setSeconds(15);
    while (date_ret.getTime() < date_now.getTime()) {
      date_ret.setSeconds(date_ret.getSeconds() + 15);
    }
    return date_ret;
  } else
  if (hour_str === '*2X' && min_str === '*2X') {
    // once every 30 seconds or twice a minute
    date_ret.setMilliseconds(0);
    date_ret.setSeconds(30);
    while (date_ret.getTime() < date_now.getTime()) {
      date_ret.setSeconds(date_ret.getSeconds() + 30);
    }
    return date_ret;
  } else
  if (hour_str === '*' && min_str === '*') {
    // once a minute 
    date_ret.setMilliseconds(0);
    date_ret.setSeconds(0);
    date_ret.setMinutes(date_ret.getMinutes() + 1);
  } else
  if (hour_str !== '*' && isNaN(hour) == false && min_str === '*') {
    // once a minute only for a given hour
    date_ret.setMilliseconds(0);
    date_ret.setSeconds(0);
    date_ret.setMinutes(date_ret.getMinutes() + 1);
    if (date_ret.getTime() < date_now.getTime()) {
      date_ret.setHours(hour);
    }
    if (date_ret.getTime() > date_now.getTime()) {
      date_ret.setDate(date_ret.getDate() + 1);
      date_ret.setSeconds(0);
      date_ret.setMinutes(0);
      date_ret.setHours(hour);
    }
  } else
  if (hour_str === '*' && min_str !== '*' && isNaN(min) == false) {
    // once a hour at a given minute
    date_ret.setMilliseconds(0);
    date_ret.setSeconds(0);
    date_ret.setMinutes(min);
    // schedule for next hour
    date_ret.setHours(date_ret.getHours() + 1);
  } else
  if (isNaN(hour) == false && isNaN(min) == false) {
    // once a day for a given hour and a given minute 
    date_ret.setMilliseconds(0);
    date_ret.setSeconds(0);
    date_ret.setMinutes(min);
    date_ret.setHours(hour);
    if (date_ret.getTime() < date_now.getTime()) {
      // schedule for tomorrow
      date_ret.setDate(date_ret.getDate() + 1);
    }
  } else {
    log('getNextRecurringDate illegal input hour_str <' + hour_str + '> min_str <' + min_str + '>');
    throw new Error('getNextRecurringDate illegal input hour_str <' + hour_str + '> min_str <' + min_str + '>');
    return null;
  }

  // Most likely redundant, note we don't apply this to '*4X' or '*2X' 
  if ((date_ret.getTime() + (1 * 5 * 1000)) < date_now.getTime()) {
    // schedule for 5 seconds in the future 
    date_ret.setTime(date_now.getTime() + 5);
  }

  return date_ret;
}

function verifyFunctionExistsViaEval(curDoc, id) {
  var result = null;
  // check for function if missing this is invalid return result
  result = eval("typeof " + curDoc.action + " === 'function';");
  if (result == false) {
    if (curDoc.verbose >= 3)
      log("Warn/Disable (No Action and No Re-Arm), because required 'action' of " +
        curDoc.action + "(doc) does not exist, id is", id);
    return result;
  }
  return result;
}

function RecurringCallback(doc) {
  // Check if further analysis is needed we only trigger on a recurring_event that is active
  if (doc.type !== "recurring_event") return;
  if (!doc.action) return;

  // ==================
  // Check if still active

  // We make sure that in KV the 'doc' still exists and that it is still active if not just 
  // return thus skipping the action and not Re-arming the timer. Note `travel-sample` is 
  // aliased to the map 'ts'
  var id = doc.type + "::" + doc.id;
  var curDoc = null;
  try {
    // read the current version of doc from KV, e.g. curDoc
    curDoc = ts[id];
  } catch (e) {} // needed for pre 6.5, note pure 6.5+ deployment returns null sans exception
  if (!curDoc) {
    if (doc.verbose >= 3)
      log("Disable (No Action and No Re-Arm), because src document controlling " +
        "recurring timer missing, id was", id);
    return; // will work for pre 6.5 and post 6.5+ logic
  }
  // look at the current doc, not the context we have been passing around to Re-arm
  if (curDoc.active != true) {
    if (curDoc.verbose >= 3)
      log("Disable (No Action and No Re-Arm), because src document controlling " +
        "recurring timer has 'active' = false, id is", id);
    return;
  }

  // ==================
  // Verify user routine exists and if so eval it 

  // Assume curDoc.action contains something like "doCronActionA" and we have a function in 
  // this handler like "doCronActionA(doc)". Below we use curDoc as the end user should be 
  // able to alter the eval'd JavaScript function.  We will execute two (2) evals.

  // First eval check the JavaScript function exists.  The eval occurs in a common 
  // utility function shared with RecurringCallback
  if (!verifyFunctionExistsViaEval(curDoc, id)) {
    // curDoc.action did not exist, we have already logged the issue
    return;
  }

  // Second eval execute and process the user function we execute the defined function 
  // with an argument of curDoc
  var result = null;
  eval("result = " + curDoc.action + "(curDoc);");
  if (curDoc.verbose >= 3)
    log("action for " + id + " executed and it returned", result);

  // ==================
  // Re-Arm the timer

  var hour = doc.hour;
  var min = doc.min;

  var date_timer = getNextRecurringDate(hour, min);
  if (curDoc.verbose >= 3) {
    log("RecurringCallback (sched date) " + date_timer);
    log('RecurringCallback create recurring timer for id ', id);
  }

  // Re-arm e.g. Re-schedule an Eventing timer
  createTimer(RecurringCallback, date_timer, id, curDoc);
}
